#include "driver/gpio.h"
#include <unistd.h>   // para usleep
#include <stdio.h>
#include <string.h>

// ==== Pines del LCD ====
#define RS 21
#define E  22
#define D4 19
#define D5 18
#define D6 17
#define D7 16

// ==== Pines del MM74C922 ====
#define D0  25  // Bit menos significativo
#define D1  26
#define D2  27
#define D3  14  // Bit más significativo
#define DATA_AVAIL  33  // Señal de dato disponible (activo en bajo)

// ==== Pines motor paso a paso ====
#define IN1 32
#define IN2 4
#define IN3 2
#define IN4 13

int velocidad = 0;
int step_index = 0;
float angulo = 0.0;

// ==== Funciones LCD ====

void lcd_send_nibble(uint8_t nibble) {
    gpio_set_level(D4, (nibble >> 0) & 1);
    gpio_set_level(D5, (nibble >> 1) & 1);
    gpio_set_level(D6, (nibble >> 2) & 1);
    gpio_set_level(D7, (nibble >> 3) & 1);

    gpio_set_level(E, 1);
    usleep(1);
    gpio_set_level(E, 0);
    usleep(100);
}

void lcd_send_byte(uint8_t val, int mode) {
    gpio_set_level(RS, mode);
    lcd_send_nibble(val >> 4);
    lcd_send_nibble(val & 0x0F);
    usleep(2000);
}

void lcd_cmd(uint8_t cmd) {
    lcd_send_byte(cmd, 0);
}

void lcd_data(uint8_t data) {
    lcd_send_byte(data, 1);
}

void lcd_init() {
    gpio_set_direction(RS, GPIO_MODE_OUTPUT);
    gpio_set_direction(E, GPIO_MODE_OUTPUT);
    gpio_set_direction(D4, GPIO_MODE_OUTPUT);
    gpio_set_direction(D5, GPIO_MODE_OUTPUT);
    gpio_set_direction(D6, GPIO_MODE_OUTPUT);
    gpio_set_direction(D7, GPIO_MODE_OUTPUT);

    usleep(15000);

    lcd_send_nibble(0x03);
    usleep(5000);
    lcd_send_nibble(0x03);
    usleep(200);
    lcd_send_nibble(0x03);
    usleep(200);
    lcd_send_nibble(0x02); // 4-bit mode

    lcd_cmd(0x28); // 4 bits, 2 líneas, 5x8
    lcd_cmd(0x0C); // Display on, cursor off
    lcd_cmd(0x06); // Incremento automático
    lcd_cmd(0x01); // Limpiar pantalla
    usleep(2000);
}

void lcd_set_cursor(int col, int row) {
    int row_offsets[] = {0x00, 0x40};
    lcd_cmd(0x80 | (col + row_offsets[row]));
}

void lcd_print(const char *s) {
    while (*s) {
        lcd_data(*s++);
    }
}

// ==== Funciones Teclado ====

int leer_tecla() {
    int b0 = gpio_get_level(D0);
    int b1 = gpio_get_level(D1);
    int b2 = gpio_get_level(D2);
    int b3 = gpio_get_level(D3);
    int codigo = (b3 << 3) | (b2 << 2) | (b1 << 1) | b0;
    return codigo;
}

void teclado_init() {
    gpio_set_direction(D0, GPIO_MODE_INPUT);
    gpio_set_direction(D1, GPIO_MODE_INPUT);
    gpio_set_direction(D2, GPIO_MODE_INPUT);
    gpio_set_direction(D3, GPIO_MODE_INPUT);
    gpio_set_direction(DATA_AVAIL, GPIO_MODE_INPUT);
}

// ==== Funciones Motor Paso a Paso ====

const int motor_steps[8][4] = {
    {0, 1, 1, 1},
    {0, 0, 1, 1},
    {1, 0, 1, 1},
    {1, 0, 0, 1},
    {1, 1, 0, 1},
    {1, 1, 0, 0},
    {1, 1, 1, 0},
    {0, 1, 1, 0}
};

void motor_init() {
    gpio_set_direction(IN1, GPIO_MODE_OUTPUT);
    gpio_set_direction(IN2, GPIO_MODE_OUTPUT);
    gpio_set_direction(IN3, GPIO_MODE_OUTPUT);
    gpio_set_direction(IN4, GPIO_MODE_OUTPUT);
}

void motor_step(int step) {
    gpio_set_level(IN1, motor_steps[step][0]);
    gpio_set_level(IN2, motor_steps[step][1]);
    gpio_set_level(IN3, motor_steps[step][2]);
    gpio_set_level(IN4, motor_steps[step][3]);
}

void motor_stop() {
    gpio_set_level(IN1, 0);
    gpio_set_level(IN2, 0);
    gpio_set_level(IN3, 0);
    gpio_set_level(IN4, 0);
}

// ==== Programa Principal ====

void app_main() {
    lcd_init();
    teclado_init();
    motor_init();

    lcd_set_cursor(0,0);
    lcd_print("Velocidad:");
    lcd_set_cursor(0,1);
    lcd_print("Angulo:");

    while (1) {
        // Leer teclado si hay dato disponible
        if (gpio_get_level(DATA_AVAIL) == 0) {
            int key = leer_tecla();

            if (key >= 1 && key <= 9) {
                velocidad = key;
            } else if (key == 0) {
                velocidad = 10;
            } else {
                velocidad = 0;
            }

            // Actualizar LCD velocidad y reset angulo
            lcd_cmd(0x01); // limpiar
            lcd_set_cursor(0,0);
            char buffer[16];
            sprintf(buffer, "Velocidad:%d", velocidad);
            lcd_print(buffer);

            lcd_set_cursor(0,1);
            sprintf(buffer, "Angulo:%.1f", angulo);
            lcd_print(buffer);

            usleep(300000); // anti-rebote
        }

        if (velocidad > 0) {
            motor_step(step_index);
            step_index = (step_index + 1) % 8;

            // Calcular ángulo (28BYJ-48 típico con 4096 pasos por vuelta)
            angulo += 360.0 / 4096.0;
            if (angulo >= 360.0) angulo -= 360.0;

            // Actualizar ángulo en LCD (segunda línea)
            lcd_set_cursor(7,1);
            char ang_buffer[10];
            sprintf(ang_buffer, "%.1f ", angulo); // espacio para limpiar caracteres
            lcd_print(ang_buffer);

            // Retraso inverso proporcional a la velocidad
            int delay_us = 2000 / velocidad;
            if (delay_us < 1000) delay_us = 1000; // evitar retrasos muy pequeños
            usleep(delay_us);
        } else {
            motor_stop();
            usleep(2000);
        }
    }
}
