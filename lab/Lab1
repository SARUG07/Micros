#include "driver/gpio.h"
#include <unistd.h>
#include <stdio.h>
#include <string.h>

// ==== Pines del LCD ====
#define RS 21
#define E  22
#define D4 19
#define D5 18
#define D6 17
#define D7 16

// ==== Pines del MM74C922 ====
#define D0  25
#define D1  26
#define D2  27
#define D3  14
#define DATA_AVAIL  33

// ==== Pines motor paso a paso ====
#define IN1 32
#define IN2 4
#define IN3 2
#define IN4 13

// ==== Pin sensor Hall ====
#define HALL_PIN  23

// ==== Variables globales ====
int velocidad = 0;
int step_index = 0;
float angulo = 0.0;
volatile int hall_detectado = 0;
volatile int hall_pulsos = 0;
const int pasos_por_vuelta_motor = 4096; // 28BYJ-48 típico
const int pasos_por_vuelta_hall = 1;     // Pulsos del hall por vuelta

// ==== LCD ====
void lcd_send_nibble(uint8_t nibble) {
    gpio_set_level(D4, (nibble >> 0) & 1);
    gpio_set_level(D5, (nibble >> 1) & 1);
    gpio_set_level(D6, (nibble >> 2) & 1);
    gpio_set_level(D7, (nibble >> 3) & 1);
    gpio_set_level(E, 1);
    usleep(1);
    gpio_set_level(E, 0);
    usleep(100);
}

void lcd_send_byte(uint8_t val, int mode) {
    gpio_set_level(RS, mode);
    lcd_send_nibble(val >> 4);
    lcd_send_nibble(val & 0x0F);
    usleep(2000);
}

void lcd_cmd(uint8_t cmd) {
    lcd_send_byte(cmd, 0);
}

void lcd_data(uint8_t data) {
    lcd_send_byte(data, 1);
}

void lcd_init() {
    gpio_set_direction(RS, GPIO_MODE_OUTPUT);
    gpio_set_direction(E, GPIO_MODE_OUTPUT);
    gpio_set_direction(D4, GPIO_MODE_OUTPUT);
    gpio_set_direction(D5, GPIO_MODE_OUTPUT);
    gpio_set_direction(D6, GPIO_MODE_OUTPUT);
    gpio_set_direction(D7, GPIO_MODE_OUTPUT);

    usleep(15000);
    lcd_send_nibble(0x03);
    usleep(5000);
    lcd_send_nibble(0x03);
    usleep(200);
    lcd_send_nibble(0x03);
    usleep(200);
    lcd_send_nibble(0x02);

    lcd_cmd(0x28);
    lcd_cmd(0x0C);
    lcd_cmd(0x06);
    lcd_cmd(0x01);
    usleep(2000);
}

void lcd_set_cursor(int col, int row) {
    int row_offsets[] = {0x00, 0x40};
    lcd_cmd(0x80 | (col + row_offsets[row]));
}

void lcd_print(const char *s) {
    while (*s) {
        lcd_data(*s++);
    }
}

// ==== Teclado ====
int leer_tecla() {
    int b0 = gpio_get_level(D0);
    int b1 = gpio_get_level(D1);
    int b2 = gpio_get_level(D2);
    int b3 = gpio_get_level(D3);
    int codigo = (b3 << 3) | (b2 << 2) | (b1 << 1) | b0;
    return codigo;
}

void teclado_init() {
    gpio_set_direction(D0, GPIO_MODE_INPUT);
    gpio_set_direction(D1, GPIO_MODE_INPUT);
    gpio_set_direction(D2, GPIO_MODE_INPUT);
    gpio_set_direction(D3, GPIO_MODE_INPUT);
    gpio_set_direction(DATA_AVAIL, GPIO_MODE_INPUT);
}

// ==== Motor ====
const int motor_steps[8][4] = {
    {0, 1, 1, 1},
    {0, 0, 1, 1},
    {1, 0, 1, 1},
    {1, 0, 0, 1},
    {1, 1, 0, 1},
    {1, 1, 0, 0},
    {1, 1, 1, 0},
    {0, 1, 1, 0}
};

void motor_init() {
    gpio_set_direction(IN1, GPIO_MODE_OUTPUT);
    gpio_set_direction(IN2, GPIO_MODE_OUTPUT);
    gpio_set_direction(IN3, GPIO_MODE_OUTPUT);
    gpio_set_direction(IN4, GPIO_MODE_OUTPUT);
}

void motor_step(int step) {
    gpio_set_level(IN1, motor_steps[step][0]);
    gpio_set_level(IN2, motor_steps[step][1]);
    gpio_set_level(IN3, motor_steps[step][2]);
    gpio_set_level(IN4, motor_steps[step][3]);
}

void motor_stop() {
    gpio_set_level(IN1, 0);
    gpio_set_level(IN2, 0);
    gpio_set_level(IN3, 0);
    gpio_set_level(IN4, 0);
}

// ==== Sensor Hall ====
void IRAM_ATTR hall_isr() {
    hall_pulsos++;
    hall_detectado = 1; // Señal para auto-calibrar
}

void hall_init() {
    gpio_set_direction(HALL_PIN, GPIO_MODE_INPUT);
    gpio_set_pull_mode(HALL_PIN, GPIO_PULLUP_ONLY);
    gpio_set_intr_type(HALL_PIN, GPIO_INTR_NEGEDGE);
    gpio_install_isr_service(0);
    gpio_isr_handler_add(HALL_PIN, hall_isr, NULL);
}

float hall_get_angulo() {
    if (hall_pulsos == 0) return 0.0;
    return (360.0 / pasos_por_vuelta_hall) * (hall_pulsos % pasos_por_vuelta_hall);
}

// ==== Programa principal ====
void app_main() {
    lcd_init();
    teclado_init();
    motor_init();
    hall_init();

    lcd_set_cursor(0,0);
    lcd_print("Velocidad:");
    lcd_set_cursor(0,1);
    lcd_print("Angulo:");

    while (1) {
        // Leer teclado
        if (gpio_get_level(DATA_AVAIL) == 0) {
            int key = leer_tecla();
            if (key >= 1 && key <= 9) {
                velocidad = key;
            } else if (key == 0) {
                velocidad = 10;
            } else {
                velocidad = 0;
            }
            lcd_cmd(0x01);
            lcd_set_cursor(0,0);
            char buffer[16];
            sprintf(buffer, "Velocidad:%d", velocidad);
            lcd_print(buffer);

            lcd_set_cursor(0,1);
            sprintf(buffer, "E:%.1f H:%.1f", angulo, hall_get_angulo());
            lcd_print(buffer);

            usleep(300000);
        }

        if (velocidad > 0) {
            motor_step(step_index);
            step_index = (step_index + 1) % 8;

            // Actualizar ángulo estimado
            angulo += 360.0 / pasos_por_vuelta_motor;
            if (angulo >= 360.0) angulo -= 360.0;

            // Auto-calibración con Hall
            if (hall_detectado) {
                angulo = 0.0; // Reset a cero cuando pasa por el imán
                hall_detectado = 0;
            }

            // Mostrar en LCD
            lcd_set_cursor(0,1);
            char ang_buffer[16];
            sprintf(ang_buffer, "E:%.1f H:%.1f", angulo, hall_get_angulo());
            lcd_print(ang_buffer);

            // Mostrar en terminal
            printf("Ángulo estimado: %.2f° | Ángulo Hall: %.2f° | Pulsos: %d\n",
                   angulo, hall_get_angulo(), hall_pulsos);

            // Control velocidad
            int delay_us = 2000 / velocidad;
            if (delay_us < 1000) delay_us = 1000;
            usleep(delay_us);
        } else {
            motor_stop();
            usleep(2000);
        }
    }
}
